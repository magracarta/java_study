package com.ohgiraffers.level01.basic;

public class Application01 {
    public static void main(String[] args) {
        /* Application01
        int x = 2;
		int y = 5;
		char c = 'A'; // 'A'의 문자코드는 65
		System.out.println(y >= 5 || x < 0 && x > 2);

        답 -> true : 뒤의 &&을 크게 한묶음은 false값 앞의 || 값은 true로
        true값 반환


		System.out.println(y += 10 - x++);
		답 - > 13
		(5+10) - 2
		++은 뒤에 붙으면 계산 후에 축적된다.


		System.out.println(x+=2);
		답 -> 5
		앞의 값에서 x가 3이 되었기 때문에 5가 된다.


		System.out.println( !('A' <= c && c <='Z') );
		답 -> false;
		A =65 , z = 90 이다. c의 값은 A로 65리 &&의 앞은 true이고
		뒤의 값은 65<90 라 뒤의값도 true 이다.
		그럼 두번째 괄호안의 값은 true 이지만 밖에 !인 부정이 있어 true가 false가 된다.

		System.out.println('C'-c);
		답 -> 2
		C의 아스키 코드 값은 67 이다 c 의 변수값은 위에서와 같이 A로 65이다
		해서 67 - 65 =2이다.


		System.out.println('5'-'0');
        답 -> 5
        문자 5는 53 문자 0은 48
        53-48 = 5

		System.out.println(c+1);
		답 -> 66
		 A의 값은 65 이고 거이에 1을 더하여 65+1= 66

		System.out.println(++c);
		답 -> 66 , B
		c 는 A이고 A=65이다, ++은 바로 더하고 값이 반환됨으로
		바로 66이된다.
		66은 B의 아스키 코드이다.

		System.out.println(c++);
		답 -> B
		++은 출력후에 계산됨으로 출력된 값은 그대로이다.

		System.out.println(c);
        답 -> C
        후에 계산된 값이 처리됨으로 결국 C가 됨


		System.out.println() 의 결과를 예측하고 이유를 설명하시오.
		*/


    }
}
